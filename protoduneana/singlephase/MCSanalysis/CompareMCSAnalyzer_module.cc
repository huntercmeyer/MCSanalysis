////////////////////////////////////////////////////////////////////////
// Class:       CompareMCSAnalyzer
// Module Type: analyzer
// File:        CompareMCSAnalyzer_module.cc
// Author: Hunter Meyer | hmeyer5@lsu.edu
// Advisor: Thomas Kutter
// Description: Comparison of various methods of momentum reconstruction
// currently available for ProtoDUNE-SP, including:
// 1) TrackMomentumCalculator
//   a) Chi2
//   b) LLHD
// 2) TrajectoryMCSFitter - MicroBooNE implementation (arxiv.org/abs/1703.06187)
// 3) A custom implementation, inspired by the MicroBooNE implementation
//   a) trkf::MCSMomentumCalculator
////////////////////////////////////////////////////////////////////////

#define _unused [[maybe_unused]]

// C++ Includes
#include <iostream>
#include <fstream>

// Root Includes
#include "TH1F.h"
#include "TH2F.h"
#include "TProfile.h"

// Framework Includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art_root_io/TFileService.h"

// LArSoft Inclues
#include "nusimdata/SimulationBase/MCParticle.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "larreco/RecoAlg/TrackMomentumCalculator.h"
#include "larreco/RecoAlg/TrajectoryMCSFitter.h"
#include "MCSMomentumCalculator.h"

// LSU Includes
#include "BackTrackerAlg.h"

class CompareMCSAnalyzer;

class CompareMCSAnalyzer : public art::EDAnalyzer {
public:

  // fhicl configuration
  struct Config {
    fhicl::Atom<art::InputTag> trackModuleLabel { fhicl::Name("TrackModuleLabel") };
    fhicl::Atom<Bool_t> shouldCreateVirtualPoints { fhicl::Name("ShouldCreateVirtualPoints"), fhicl::Comment("Determines if the mcs segment result will create the segments using virtual points or not"), false};

    fhicl::Table<trkf::TrajectoryMCSFitter::Config> trajectorymcsfitter { fhicl::Name("trajectorymcsfitter") };

    fhicl::Table<trkf::MCSMomentumCalculator::Config> momentumCalculator { fhicl::Name("momentumCalculator") };
  };
  using Parameters = art::EDAnalyzer::Table<Config>;

  //explicit CompareMCSAnalyzer(fhicl::ParameterSet const & p);
  explicit CompareMCSAnalyzer(art::EDAnalyzer::Table<Config> const & t);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CompareMCSAnalyzer(CompareMCSAnalyzer const &) = delete;
  CompareMCSAnalyzer(CompareMCSAnalyzer &&) = delete;
  CompareMCSAnalyzer & operator = (CompareMCSAnalyzer const &) = delete;
  CompareMCSAnalyzer & operator = (CompareMCSAnalyzer &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Functions you write
  template<typename Point> Bool_t inDetector(Point point) const;
  Double_t highland(Double_t momentum, Double_t l);
  double deltaP(double p, double l);
  std::vector<double> getThetaOverSigma(double p, std::vector<double> thetaXZprimevec, std::vector<double> thetaYZprimevec, std::vector<double> lengthsvec);
  Double_t fractionalDifference(Double_t trueMomentum, Double_t mcsMomentum);

  // Functions that you can change but they technically already exist
  // You just rewrite them for your needs.
  // Examples: beginJob, endJob, etc.
  void beginJob();
  void endJob();

private:
  // Retrieved from fhicl parameters
  const art::InputTag fTrackModuleLabel;
  const Bool_t fShouldCreateVirtualPoints;
  const trkf::TrajectoryMCSFitter::Parameters fTrajectoryMCSFitterParameters;
  const fhicl::Table<trkf::MCSMomentumCalculator::Config> fMomentumCalculatorParameters;

  // True Data
  // =====================================================

  // True Pos Info
  TH2F* trueXVsZ_HIST;
  TH2F* trueYVsZ_HIST;

  TH1F* trueMomentum_HIST;

  // TODO: Consider adding 2D/projected modifiers to names?

  // True Linear MCS Momentum
  TH1F* trueLinear_MCSMomentum_HIST;
  TH2F* trueLinear_MCSMomentumVsTrueMomentum_HIST;

  TH2F* trueLinear_fracDiffVsTrueMomentum_HIST;
  TH1F* trueLinear_MCSMomentumTrueMomentumDiff_HIST;

  TH2F* contained_trueLinear_MCSMomentumVsTrueMomentum_HIST;
  TH2F* exiting_trueLinear_MCSMomentumVsTrueMomentum_HIST;
  
  // True Polygonal MCS Momentum
  TH1F* truePolygonal_MCSMomentum_HIST;
  TH2F* truePolygonal_MCSMomentumVsTrueMomentum_HIST;

  TH2F* truePolygonal_fracDiffVsTrueMomentum_HIST;
  
  TH2F* contained_truePolygonal_MCSMomentumVsTrueMomentum_HIST;
  TH2F* exiting_truePolygonal_MCSMomentumVsTrueMomentum_HIST;

  // TODO: frac diff contained Vs. exiting plots.

  // True Linear 3D MCS Momentum
  TH1F* trueLinear3D_MCSMomentum_HIST;
  TH2F* trueLinear3D_MCSMomentumVsTrueMomentum_HIST;

  TH2F* trueLinear3D_fracDiffVsTrueMomentum_HIST;

  TH2F* contained_trueLinear3D_MCSMomentumVsTrueMomentum_HIST;
  TH2F* exiting_trueLinear3D_MCSMomentumVsTrueMomentum_HIST;

  // True Polygonal 3D MCS Momentum
  TH1F* truePolygonal3D_MCSMomentum_HIST;
  TH2F* truePolygonal3D_MCSMomentumVsTrueMomentum_HIST;
  
  TH2F* truePolygonal3D_fracDiffVsTrueMomentum_HIST;

  TH2F* contained_truePolygonal3D_MCSMomentumVsTrueMomentum_HIST;
  TH2F* exiting_truePolygonal3D_MCSMomentumVsTrueMomentum_HIST;

  // =====================================================

  // Reconstructed Data
  // #####################################################

  // Reco Pos Info
  TH2F* recoXVsZ_HIST;
  TH2F* recoYVsZ_HIST;

  // Reco Linear MCS Momentum
  TH1F* recoLinear_MCSMomentum_HIST;
  TH2F* recoLinear_MCSMomentumVsTrueMomentum_HIST;

  TH2F* recoLinear_fracDiffVsTrueMomentum_HIST;
  TH1F* recoLinear_MCSMomentumTrueMomentumDiff_HIST;

  TH2F* contained_recoLinear_MCSMomentumVsTrueMomentum_HIST;
  TH2F* exiting_recoLinear_MCSMomentumVsTrueMomentum_HIST;

  // Reco Polygonal MCS Momentum
  TH1F* recoPolygonal_MCSMomentum_HIST;
  TH2F* recoPolygonal_MCSMomentumVsTrueMomentum_HIST;

  TH2F* recoPolygonal_fracDiffVsTrueMomentum_HIST;

  TH2F* contained_recoPolygonal_MCSMomentumVsTrueMomentum_HIST;
  TH2F* exiting_recoPolygonal_MCSMomentumVsTrueMomentum_HIST;

  // Reco Linear 3D MCS Momentum
  TH1F* recoLinear3D_MCSMomentum_HIST;
  TH2F* recoLinear3D_MCSMomentumVsTrueMomentum_HIST;

  TH2F* recoLinear3D_fracDiffVsTrueMomentum_HIST;

  TH2F* contained_recoLinear3D_MCSMomentumVsTrueMomentum_HIST;
  TH2F* exiting_recoLinear3D_MCSMomentumVsTrueMomentum_HIST;

  // Reco Polygonal 3D MCS Momentum
  TH1F* recoPolygonal3D_MCSMomentum_HIST;
  TH2F* recoPolygonal3D_MCSMomentumVsTrueMomentum_HIST;
  
  TH2F* recoPolygonal3D_fracDiffVsTrueMomentum_HIST;

  TH2F* contained_recoPolygonal3D_MCSMomentumVsTrueMomentum_HIST;
  TH2F* exiting_recoPolygonal3D_MCSMomentumVsTrueMomentum_HIST;

  // TODO: Add extra plots from above to TMC and TMF, revise name structure.

  // Chi2 TMC Momentum
  TH1F* chi2TMCMomentum_HIST;
  TH2F* chi2TMCMomentumVsTrueMomentum_HIST;

  // LLHD TMC Momentum
  TH1F* llhdTMCMomentum_HIST;
  TH2F* llhdTMCMomentumVsTrueMomentum_HIST;

  // TrajectoryMCSFitter Momentum
  TH1F* tmfMomentum_HIST;
  TH2F* tmfMomentumVsTrueMomentum_HIST;
  // #####################################################
};

CompareMCSAnalyzer::CompareMCSAnalyzer(art::EDAnalyzer::Table<CompareMCSAnalyzer::Config> const & t) : 
  art::EDAnalyzer(t), 
  fTrackModuleLabel(t().trackModuleLabel()),
  fShouldCreateVirtualPoints(t().shouldCreateVirtualPoints()),
  fTrajectoryMCSFitterParameters(t().trajectorymcsfitter), 
  fMomentumCalculatorParameters(t().momentumCalculator)
{}

void CompareMCSAnalyzer::analyze(art::Event const & e) {
  std::cout << "Event number: " << e.event() << std::endl;

  // simb::MCParticle analysis
  /* Commented out for now, may move some MCParticle analysis in the trackList loop to here.
     auto particleListHandle = e.getValidHandle<std::vector<simb::MCParticle> >("largeant");
     std::vector<art::Ptr<simb::MCParticle> > particleList;
     art::fill_ptr_vector(particleList, particleListHandle);
     std::cout << "Number of Particles: " << particleList.size() << std::endl;
     size_t nParticles = particleList.size();
     for(size_t iParticle = 0; iParticle < nParticles; ++iParticle) {
     art::Ptr<simb::MCParticle> particle = particleList.at(iParticle);
     if(particle->Trajectory().TotalLength() >= 100 && particle->PdgCode() == 13) {
     // Nothing for now, probably won't compile
     } // if this trajectory point is in the detector
     } // For trajectory point in particle
     } // if particle trajectory length >= 100 cm and PDG == 13
     } // for particle in particleList
  */

  // recob::Track analysis
  auto trackListHandle = e.getValidHandle<std::vector<recob::Track> >(fTrackModuleLabel);
  std::vector<art::Ptr<recob::Track> > trackList;
  art::fill_ptr_vector(trackList,trackListHandle);
  std::cout << "Number of Tracks: " << trackList.size() << std::endl;

  // Various Momentum Calculators
  trkf::TrackMomentumCalculator trackMomentumCalculator;
  trkf::TrajectoryMCSFitter trajectoryMCSFitter(fTrajectoryMCSFitterParameters);
  trkf::MCSSegmentCalculator segmentCalculator = trkf::MCSSegmentCalculator(fMomentumCalculatorParameters().angleCalculator().segmentCalculator);
  trkf::MCSMomentumCalculator mcsMomentumCalculator = trkf::MCSMomentumCalculator(fMomentumCalculatorParameters);

  // LSU Backtracker
  lsu::BackTrackerAlg backtracker;

  // Loop through the list of reconstructed tracks
  size_t nTracks = trackList.size();

  Int_t numberOfMuonTracks = 0;
  art::Ptr<recob::Track> lastMuonTrack;
  // Loop through reconstructed tracks to determine if the tracks are well-reconstructed.
  for(size_t iTrack = 0; iTrack < nTracks; iTrack++) {
    art::Ptr<recob::Track> track = trackList.at(iTrack);
    simb::MCParticle particle = backtracker.getMCParticle(track, e, fTrackModuleLabel.label());
    if(particle.PdgCode() == 13 && track->Length() >= 100) {
      ++numberOfMuonTracks;
      lastMuonTrack = track;
    }
  }

  _unused art::Ptr<recob::Track> wellReconstructedTrack;
  _unused Bool_t trackIsWellReconstructed = false;
  if(numberOfMuonTracks == 1) {
    trackIsWellReconstructed = true;
    wellReconstructedTrack = lastMuonTrack;
  }

  //* Comment is for if we switch back to now using wellReconstructedTrack selection criteria.
  if(trackIsWellReconstructed) {
    art::Ptr<recob::Track> track = wellReconstructedTrack;
    // */
    /* Comment is for if we use wellReconstructedTrack selection criteria.
    // Commented out since we added the wellReconstructedTrack stuff earlier.
    // Loop through well-reconstructed tracks.
    for(size_t iTrack = 0; iTrack < nTracks; iTrack++) {
    art::Ptr<recob::Track> track = trackList.at(iTrack);
    // */
    // Only run this analysis if the track length is greater than 100 cm
    if(track->Length() >= 100) {

      // True Momentum
      simb::MCParticle particle = backtracker.getMCParticle(track, e, fTrackModuleLabel.label()); // TODO: BackTrackerAlg should probably take the label as the input parameter in the constructor.
      double trueMomentum = particle.P();

      trkf::MCSSegmentCalculator::MCSSegmentResult trueSegmentResult = segmentCalculator.GetResult(particle, fShouldCreateVirtualPoints);
      trkf::MCSSegmentCalculator::MCSSegmentResult recoSegmentResult = segmentCalculator.GetResult(*track, fShouldCreateVirtualPoints);

      trkf::MCSMomentumCalculator::Result trueLinear_MCS = mcsMomentumCalculator.GetResult(trueSegmentResult, 0);
      trkf::MCSMomentumCalculator::Result truePolygonal_MCS = mcsMomentumCalculator.GetResult(trueSegmentResult, 1);
      trkf::MCSMomentumCalculator::Result trueLinear3D_MCS = mcsMomentumCalculator.GetResult(trueSegmentResult, 2);
      trkf::MCSMomentumCalculator::Result truePolygonal3D_MCS = mcsMomentumCalculator.GetResult(trueSegmentResult, 3);
      // trkf::MCSMomentumCalculator::Result trueLinear_MCS = mcsMomentumCalculator.GetResult(particle, 0);
      // trkf::MCSMomentumCalculator::Result truePolygonal_MCS = mcsMomentumCalculator.GetResult(particle, 1);
      // trkf::MCSMomentumCalculator::Result trueLinear3D_MCS = mcsMomentumCalculator.GetResult(particle, 2);
      // trkf::MCSMomentumCalculator::Result truePolygonal3D_MCS = mcsMomentumCalculator.GetResult(particle, 3);
      trueMomentum_HIST->Fill(trueMomentum); // TODO: If there are multiple tracks that reconstruct back to the same MCParticle, then this will be filled twice. This should probably be filled not in the trackList loop.

      trkf::MCSMomentumCalculator::Result recoLinear_MCS = mcsMomentumCalculator.GetResult(recoSegmentResult, 0);
      trkf::MCSMomentumCalculator::Result recoPolygonal_MCS = mcsMomentumCalculator.GetResult(recoSegmentResult, 1);
      trkf::MCSMomentumCalculator::Result recoLinear3D_MCS = mcsMomentumCalculator.GetResult(recoSegmentResult, 2);
      trkf::MCSMomentumCalculator::Result recoPolygonal3D_MCS = mcsMomentumCalculator.GetResult(recoSegmentResult, 3);
      // trkf::MCSMomentumCalculator::Result recoLinear_MCS = mcsMomentumCalculator.GetResult(*track);
      // trkf::MCSMomentumCalculator::Result recoPolygonal_MCS = mcsMomentumCalculator.GetResult(*track, 1);
      // trkf::MCSMomentumCalculator::Result recoLinear3D_MCS = mcsMomentumCalculator.GetResult(*track, 2);
      // trkf::MCSMomentumCalculator::Result recoPolygonal3D_MCS = mcsMomentumCalculator.GetResult(*track, 3);
      // TODO: Verify that curvy tracks were no longer occuring, then show that they are now fixed...
      // TODO: Plot the theta/sigma plots as well. (or in MCSAngleAnalysis_module.cc) (derived in the trkf::MCSMomentumCalculator::Result?)
      // TODO: Consider adding the sqrt(2) term, what happens to these plots?
      // TODO: Add momentum fractional bias and resolution.

      // Linear MCS Momentum
      double recoLinear_MCSMomentum = recoLinear_MCS.GetMCSMomentum();

      // Polygonal MCS Momentum
      double recoPolygonal_MCSMomentum = recoPolygonal_MCS.GetMCSMomentum();

      // Linear 3D MCS Momentum
      double recoLinear3D_MCSMomentum = recoLinear3D_MCS.GetMCSMomentum();

      // Polygonal 3D MCS Momentum
      double recoPolygonal3D_MCSMomentum = recoPolygonal3D_MCS.GetMCSMomentum();

      // True Linear MCS Momentum
      double trueLinear_MCSMomentum = trueLinear_MCS.GetMCSMomentum();

      // True Polygonal MCS Momentum
      double truePolygonal_MCSMomentum = truePolygonal_MCS.GetMCSMomentum();

      // True Linear 3D MCS Momentum
      double trueLinear3D_MCSMomentum = trueLinear3D_MCS.GetMCSMomentum();

      // True Polygonal 3D MCS Momentum
      double truePolygonal3D_MCSMomentum = truePolygonal3D_MCS.GetMCSMomentum();

      // Chi2 TMC Momentum
      double chi2TMCMomentum = trackMomentumCalculator.GetMomentumMultiScatterChi2(track);

      // LLHD TMC Momentum
      double llhdTMCMomentum = trackMomentumCalculator.GetMomentumMultiScatterLLHD(track);

      // TrajectoryMCSFitter
      recob::MCSFitResult mcsFitResult = trajectoryMCSFitter.fitMcs(*track);
      double tmfMomentum = (double) mcsFitResult.fwdMomentum();

      // Plot My Linear MCS Momentum
      recoLinear_MCSMomentum_HIST->Fill(recoLinear_MCSMomentum);
      recoLinear_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, recoLinear_MCSMomentum);

      recoLinear_fracDiffVsTrueMomentum_HIST->Fill(trueMomentum, fractionalDifference(trueMomentum, recoLinear_MCSMomentum));
      recoLinear_MCSMomentumTrueMomentumDiff_HIST->Fill(recoLinear_MCSMomentum - trueMomentum);

      // Plot My Polygonal MCS Momentum
      recoPolygonal_MCSMomentum_HIST->Fill(recoPolygonal_MCSMomentum);
      recoPolygonal_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, recoPolygonal_MCSMomentum);

      recoPolygonal_fracDiffVsTrueMomentum_HIST->Fill(trueMomentum, fractionalDifference(trueMomentum, recoPolygonal_MCSMomentum));

      // Plot My Linear 3D MCS Momentum
      recoLinear3D_MCSMomentum_HIST->Fill(recoLinear3D_MCSMomentum);
      recoLinear3D_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, recoLinear3D_MCSMomentum);

      recoLinear3D_fracDiffVsTrueMomentum_HIST->Fill(trueMomentum, fractionalDifference(trueMomentum, recoLinear3D_MCSMomentum));

      // Plot My Polygonal 3D MCS Momentum
      recoPolygonal3D_MCSMomentum_HIST->Fill(recoPolygonal3D_MCSMomentum);
      recoPolygonal3D_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, recoPolygonal3D_MCSMomentum);

      recoPolygonal3D_fracDiffVsTrueMomentum_HIST->Fill(trueMomentum, fractionalDifference(trueMomentum, recoPolygonal3D_MCSMomentum));

      // Plot My True Linear MCS Momentum
      trueLinear_MCSMomentum_HIST->Fill(trueLinear_MCSMomentum);
      trueLinear_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, trueLinear_MCSMomentum);

      trueLinear_fracDiffVsTrueMomentum_HIST->Fill(trueMomentum, fractionalDifference(trueMomentum, trueLinear_MCSMomentum));
      trueLinear_MCSMomentumTrueMomentumDiff_HIST->Fill(trueLinear_MCSMomentum - trueMomentum);

      // Plot My True Polygonal MCS Momentum
      truePolygonal_MCSMomentum_HIST->Fill(truePolygonal_MCSMomentum);
      truePolygonal_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, truePolygonal_MCSMomentum);

      truePolygonal_fracDiffVsTrueMomentum_HIST->Fill(trueMomentum, fractionalDifference(trueMomentum, truePolygonal_MCSMomentum));

      // Plot My True Linear 3D MCS Momentum
      trueLinear3D_MCSMomentum_HIST->Fill(trueLinear3D_MCSMomentum);
      trueLinear3D_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, trueLinear3D_MCSMomentum);

      trueLinear3D_fracDiffVsTrueMomentum_HIST->Fill(trueMomentum, fractionalDifference(trueMomentum, trueLinear3D_MCSMomentum));

      // Plot My True Polygonal 3D MCS Momentum
      truePolygonal3D_MCSMomentum_HIST->Fill(truePolygonal3D_MCSMomentum);
      truePolygonal3D_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, truePolygonal3D_MCSMomentum);
      
      truePolygonal3D_fracDiffVsTrueMomentum_HIST->Fill(trueMomentum, fractionalDifference(trueMomentum, truePolygonal3D_MCSMomentum));

      // Check if the particle is contained or exiting.
      if(inDetector(particle.EndPosition())) {
	// Particle is contained.
	contained_recoLinear_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, recoLinear_MCSMomentum);
	contained_recoPolygonal_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, recoPolygonal_MCSMomentum);
	contained_recoLinear3D_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, recoLinear3D_MCSMomentum);
	contained_recoPolygonal3D_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, recoPolygonal3D_MCSMomentum);

	contained_trueLinear_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, trueLinear_MCSMomentum);
	contained_truePolygonal_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, truePolygonal_MCSMomentum);
	contained_trueLinear3D_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, trueLinear3D_MCSMomentum);
	contained_truePolygonal3D_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, truePolygonal3D_MCSMomentum);
      } else {
	// Particle is exiting.
	exiting_recoLinear_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, recoLinear_MCSMomentum);
	exiting_recoPolygonal_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, recoPolygonal_MCSMomentum);
	exiting_recoLinear3D_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, recoLinear3D_MCSMomentum);
	exiting_recoPolygonal3D_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, recoPolygonal3D_MCSMomentum);

	exiting_trueLinear_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, trueLinear_MCSMomentum);
	exiting_truePolygonal_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, truePolygonal_MCSMomentum);
	exiting_trueLinear3D_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, trueLinear3D_MCSMomentum);
	exiting_truePolygonal3D_MCSMomentumVsTrueMomentum_HIST->Fill(trueMomentum, truePolygonal3D_MCSMomentum);
      }

      // Plot Chi2 TMC Momentum
      chi2TMCMomentum_HIST->Fill(chi2TMCMomentum);
      chi2TMCMomentumVsTrueMomentum_HIST->Fill(trueMomentum, chi2TMCMomentum);

      // Plot LLHD TMC Momentum
      llhdTMCMomentum_HIST->Fill(llhdTMCMomentum);
      llhdTMCMomentumVsTrueMomentum_HIST->Fill(trueMomentum, llhdTMCMomentum);

      // Plot TMF Momentum
      tmfMomentum_HIST->Fill(tmfMomentum);
      tmfMomentumVsTrueMomentum_HIST->Fill(trueMomentum, tmfMomentum);

    } // if length > 100
  } // for iTrack
} // analyze function

void CompareMCSAnalyzer::beginJob() {
  art::ServiceHandle<art::TFileService> tfs; // Consider moving to private, if we do endJob analysis that needs to be saved (such as sigmaRES analysis).

  // Run MCSMomentumCalculator tests.
  trkf::MCSMomentumCalculator().RunTest();

  // True Data
  // ========================================================================

  // True Position Info
  trueXVsZ_HIST = tfs->make<TH2F>("trueXVsZ_HIST","True X vs. Z; z (cm); x (cm)", 701, -0.5, 700.5, 701, -350.5, 350.5);
  trueYVsZ_HIST = tfs->make<TH2F>("trueYVsZ_HIST","True Y vs. Z; z (cm); y (cm)", 701, -0.5, 700.5, 601, -0.5, 600.5);

  // True Momentum
  trueMomentum_HIST = tfs->make<TH1F>("trueMomentum_HIST","MC Particle Momentum; True Momentum (GeV/c); Counts / bin",100,0,10);

  // TODO: Set stats to 0 for all plots? Is there a default I can set instead?
  // TODO: Change axis titles to not have method information, keep that info to the hist name and title, will free up space in the long term and makes copying a little easier with less to change.
  // TODO: Over-arching change throughout all code: Change Polygonal to just Poly.  Will free up so much space.

  // True Linear MCS Momentum
  trueLinear_MCSMomentum_HIST = tfs->make<TH1F>("trueLinear_MCSMomentum_HIST","True Linear MCS Momentum; True Linear MCS Momentum (GeV/c); Counts / bin", 751, -0.05, 7.55);
  trueLinear_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("trueLinear_MCSMomentumVsTrueMomentum_HIST","True Linear MCS Momentum vs True Momentum; True Momentum (GeV/c); True Linear MCS Momentum (GeV/c)",751,-0.05,7.55,751,-0.05,7.55);
  trueLinear_MCSMomentumVsTrueMomentum_HIST->SetStats(0);

  trueLinear_fracDiffVsTrueMomentum_HIST = tfs->make<TH2F>("trueLinear_fracDiffVsTrueMomentum_HIST","True Linear Fractional Difference vs. True Momentum; True Momentum (GeV/c); Fractional Difference", 751, -0.05, 7.55, 50, -1.0, 1.0);
  trueLinear_MCSMomentumTrueMomentumDiff_HIST = tfs->make<TH1F>("trueLinear_MCSMomentumTrueMomentumDiff_HIST", "True Linear MCS Momentum - True Momentum; Difference (MCS - True); Counts / bin", 81, -4.5, 4.05);

  contained_trueLinear_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("contained_trueLinear_MCSMomentumVsTrueMomentum_HIST","Contained True Linear MCS Momentum vs. True Momentum; True Momentum (GeV/c); True Linear MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);
  exiting_trueLinear_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("exiting_trueLinear_MCSMomentumVsTrueMomentum_HIST","Exiting True Linear MCS Momentum vs. True Momentum; True Momentum (GeV/c); True Linear MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);

  // True Polygonal MCS Momentum
  truePolygonal_MCSMomentum_HIST = tfs->make<TH1F>("truePolygonal_MCSMomentum_HIST","True Poly MCS Momentum; True Poly MCS Momentum (GeV/c); Counts / bin",751,-0.05,7.55);
  truePolygonal_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("truePolygonal_MCSMomentumVsTrueMomentum_HIST","True Poly MCS Momentum vs True Momentum; True Momentum (GeV/c); True Poly MCS Momentum (GeV/c)",751,-0.05,7.55,751,-0.05,7.55);

  truePolygonal_fracDiffVsTrueMomentum_HIST = tfs->make<TH2F>("truePolygonal_fracDiffVsTrueMomentum_HIST","True Poly Fractional Difference vs. True Momentum; True Momentum (GeV/c); Fractional Difference", 751, -0.05, 7.55, 50, -1.0, 1.0);

  contained_truePolygonal_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("contained_truePolygonal_MCSMomentumVsTrueMomentum_HIST","Contained True Poly MCS Momentum vs. True Momentum; True Momentum (GeV/c); True Poly MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);
  exiting_truePolygonal_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("exiting_truePolygonal_MCSMomentumVsTrueMomentum_HIST","Exiting True Poly MCS Momentum vs. True Momentum; True Momentum (GeV/c); True Poly MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);

  // True Linear 3D MCS Momentum
  trueLinear3D_MCSMomentum_HIST = tfs->make<TH1F>("trueLinear3D_MCSMomentum_HIST","True Linear 3D MCS Momentum; True Linear 3D MCS Momentum (GeV/c); Counts / bin", 751, -0.05, 7.55);
  trueLinear3D_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("trueLinear3D_MCSMomentumVsTrueMomentum_HIST","True Linear 3D MCS Momentum Vs True Momentum; True Momentum (GeV/c); True Linear 3D MCS Momentum (GeV/c)",751,-0.05,7.55,751,-0.05,7.55);
  trueLinear3D_MCSMomentumVsTrueMomentum_HIST->SetStats(0);

  trueLinear3D_fracDiffVsTrueMomentum_HIST = tfs->make<TH2F>("trueLinear3D_fracDiffVsTrueMomentum_HIST","True Linear 3D Fractional Difference vs. True Momentum; True Momentum (GeV/c); Fractional Difference (true trajectory)", 751, -0.05, 7.55, 50, -1.0, 1.0);
  trueLinear3D_fracDiffVsTrueMomentum_HIST->SetStats(0);

  contained_trueLinear3D_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("contained_trueLinear3D_MCSMomentumVsTrueMomentum_HIST","Contained True Linear 3D MCS Momentum vs. True Momentum; True Momentum (GeV/c); True Linear 3D MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);
  exiting_trueLinear3D_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("exiting_trueLinear3D_MCSMomentumVsTrueMomentum_HIST","Exiting True Linear 3D MCS Momentum vs. True Momentum; True Momentum (GeV/c); True Linear 3D MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);

  // True Polygonal 3D MCS Momentum
  truePolygonal3D_MCSMomentum_HIST = tfs->make<TH1F>("truePolygonal3D_MCSMomentum_HIST","True Poly 3D MCS Momentum; True Poly 3D MCS Momentum (GeV/c); Counts / bin", 751, -0.05, 7.55);
  truePolygonal3D_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("truePolygonal3D_MCSMomentumVsTrueMomentum_HIST","True Poly 3D MCS Momentum vs True Momentum; True Momentum (GeV/c); True Poly 3D MCS Momentum (GeV/c)",751,-0.05,7.55,751,-0.05,7.55);
  truePolygonal3D_MCSMomentumVsTrueMomentum_HIST->SetStats(0);

  truePolygonal3D_fracDiffVsTrueMomentum_HIST = tfs->make<TH2F>("truePolygonal3D_fracDiffVsTrueMomentum_HIST","True Poly 3D Fractional Difference vs. True Momentum; True Momentum (GeV/c); Fractional Difference (true trajectory)", 751, -0.05, 7.55, 50, -1.0, 1.0);
  truePolygonal3D_fracDiffVsTrueMomentum_HIST->SetStats(0);

  contained_truePolygonal3D_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("contained_truePolygonal3D_MCSMomentumVsTrueMomentum_HIST","Contained True 3D MCS Momentum vs. True Momentum; True Momentum (GeV/c); True Poly 3D MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);
  exiting_truePolygonal3D_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("exiting_truePolygonal3D_MCSMomentumVsTrueMomentum_HIST","Exiting True 3D MCS Momentum vs. True Momentum; True Momentum (GeV/c); True Poly 3D MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);

  // ========================================================================

  // Reconstructed Data
  // ########################################################################
  // Reco Position Info
  recoXVsZ_HIST = tfs->make<TH2F>("recoXVsZ_HIST","Reco X vs. Z; z (cm); x (cm)", 701, -0.5, 700.5, 701, -350.5, 350.5);
  recoYVsZ_HIST = tfs->make<TH2F>("recoYVsZ_HIST","Reco Y vs. Z; z (cm); y (cm)", 701, -0.5, 700.5, 601, -0.5, 600.5);

  // Reco Linear MCS Momentum
  recoLinear_MCSMomentum_HIST = tfs->make<TH1F>("recoLinear_MCSMomentum_HIST","Reco Linear MCS Momentum; Reco Linear MCS Momentum (GeV/c); Counts / bin",751,-0.05,7.55);
  recoLinear_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("recoLinear_MCSMomentumVsTrueMomentum_HIST","Reco Linear MCS Momentum vs True Momentum; True Momentum (GeV/c); Reco Linear MCS Momentum (GeV/c)",751,-0.05,7.55,751,-0.05,7.55);
  recoLinear_MCSMomentumVsTrueMomentum_HIST->SetStats(0);

  recoLinear_fracDiffVsTrueMomentum_HIST = tfs->make<TH2F>("recoLinear_fracDiffVsTrueMomentum_HIST","Reco Linear Fractional Difference vs. True Momentum; True Momentum (GeV/c); Fractional Difference", 751, -0.05, 7.55, 50, -1.0, 1.0);

  contained_recoLinear_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("contained_recoLinear_MCSMomentumVsTrueMomentum_HIST","Contained Reco Linear MCS Momentum vs. True Momentum; True Momentum (GeV/c); Reco Linear MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);
  exiting_recoLinear_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("exiting_recoLinear_MCSMomentumVsTrueMomentum_HIST","Exiting Reco Linear MCS Momentum vs. True Momentum; True Momentum (GeV/c); Reco Linear MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);

  // Reco Polygonal MCS Momentum
  recoPolygonal_MCSMomentum_HIST = tfs->make<TH1F>("recoPolygonal_MCSMomentum_HIST","Reco Poly MCS Momentum; Reco Poly MCS Momentum (GeV/c); Counts / bin",751,-0.05,7.55);
  recoPolygonal_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("recoPolygonal_MCSMomentumVsTrueMomentum_HIST","Reco Poly MCS Momentum vs True Momentum; True Momentum (GeV/c); Reco Poly MCS Momentum (GeV/c)",751,-0.05,7.55,751,-0.05,7.55);

  recoPolygonal_fracDiffVsTrueMomentum_HIST = tfs->make<TH2F>("recoPolygonal_fracDiffVsTrueMomentum_HIST","Reco Poly Fractional Difference vs. True Momentum; True Momentum (GeV/c); Fractional Difference", 751, -0.05, 7.55, 50, -1.0, 1.0);
  recoLinear_MCSMomentumTrueMomentumDiff_HIST = tfs->make<TH1F>("recoLinear_MCSMomentumTrueMomentumDiff_HIST", "Reco Linear MCS Momentum - True Momentum; Difference (MCS - True); Counts / bin", 81, -4.5, 4.05);

  contained_recoPolygonal_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("contained_recoPolygonal_MCSMomentumVsTrueMomentum_HIST","Contained Reco Poly MCS Momentum vs. True Momentum; True Momentum (GeV/c); Reco Poly MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);
  exiting_recoPolygonal_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("exiting_recoPolygonal_MCSMomentumVsTrueMomentum_HIST","Exiting Reco Poly MCS Momentum vs. True Momentum; True Momentum (GeV/c); Reco Poly MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);

  // Reco Linear 3D MCS Momentum
  recoLinear3D_MCSMomentum_HIST = tfs->make<TH1F>("recoLinear3D_MCSMomentum_HIST","Reco Linear 3D MCS Momentum; Reco Linear 3D MCS Momentum (GeV/c); Counts / bin", 751, -0.05, 7.55);
  recoLinear3D_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("recoLinear3D_MCSMomentumVsTrueMomentum_HIST","Reco Linear 3D MCS Momentum vs True Momentum; True Momentum (GeV/c); Reco Linear 3D MCS Momentum (GeV/c)",751,-0.05,7.55,751,-0.05,7.55);
  recoLinear3D_MCSMomentumVsTrueMomentum_HIST->SetStats(0);

  recoLinear3D_fracDiffVsTrueMomentum_HIST = tfs->make<TH2F>("recoLinear3D_fracDiffVsTrueMomentum_HIST","Reco Linear 3D Fractional Difference vs. True Momentum; True Momentum (GeV/c); Fractional Difference (true trajectory)", 751, -0.05, 7.55, 50, -1.0, 1.0);
  recoLinear3D_fracDiffVsTrueMomentum_HIST->SetStats(0);

  contained_recoLinear3D_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("contained_recoLinear3D_MCSMomentumVsTrueMomentum_HIST","Contained Reco Linear 3D MCS Momentum vs. True Momentum; True Momentum (GeV/c); Reco Linear 3D MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);
  exiting_recoLinear3D_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("exiting_recoLinear3D_MCSMomentumVsTrueMomentum_HIST","Exiting Reco Linear 3D MCS Momentum vs. True Momentum; True Momentum (GeV/c); Reco Linear 3D MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);

  // Reco Polygonal 3D MCS Momentum
  recoPolygonal3D_MCSMomentum_HIST = tfs->make<TH1F>("recoPolygonal3D_MCSMomentum_HIST","Reco Poly 3D MCS Momentum; Reco Poly 3D MCS Momentum (GeV/c); Counts / bin", 751, -0.05, 7.55);
  recoPolygonal3D_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("recoPolygonal3D_MCSMomentumVsTrueMomentum_HIST","Reco Poly 3D MCS Momentum vs True Momentum; True Momentum (GeV/c); Reco Poly 3D MCS Momentum (GeV/c)",751,-0.05,7.55,751,-0.05,7.55);
  recoPolygonal3D_MCSMomentumVsTrueMomentum_HIST->SetStats(0);

  recoPolygonal3D_fracDiffVsTrueMomentum_HIST = tfs->make<TH2F>("recoPolygonal3D_fracDiffVsTrueMomentum_HIST","Reco Poly 3D Fractional Difference vs. True Momentum; True Momentum (GeV/c); Fractional Difference (true trajectory)", 751, -0.05, 7.55, 50, -1.0, 1.0);
  recoPolygonal3D_fracDiffVsTrueMomentum_HIST->SetStats(0);

  contained_recoPolygonal3D_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("contained_recoPolygonal3D_MCSMomentumVsTrueMomentum_HIST","Contained Reco Poly 3D MCS Momentum vs. True Momentum; True Momentum (GeV/c); Reco Poly 3D MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);
  exiting_recoPolygonal3D_MCSMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("exiting_recoPolygonal3D_MCSMomentumVsTrueMomentum_HIST","Exiting Reco Poly 3D MCS Momentum vs. True Momentum; True Momentum (GeV/c); Reco Poly 3D MCS Momentum", 751, -0.05, 7.55, 751, -0.05, 7.55);

  // Chi2 TMC Momentum
  chi2TMCMomentum_HIST = tfs->make<TH1F>("chi2TMCMomentum_HIST","Chi2 TMC Momentum; Chi2 TMC Momentum (GeV/c); Counts / bin", 751, -0.05, 7.55);
  chi2TMCMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("chi2TMCMomentumVsTrueMomentum_HIST","Chi2 TMC Momentum vs True Momentum; True Momentum (GeV/c); Chi2 TMC Momentum (GeV/c)",751,-0.05, 7.55, 751, -0.05, 7.55);

  // LLHD TMC Momentum
  llhdTMCMomentum_HIST = tfs->make<TH1F>("llhdTMCMomentum_HIST","Llhd TMC Momentum; Llhd TMC Momentum (GeV/c); Counts / bin", 751, -0.05, 7.55);
  llhdTMCMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("llhdTMCMomentumVsTrueMomentum_HIST","Llhd TMC Momentum vs True Momentum; True Momentum (GeV/c); Llhd TMC Momentum (GeV/c)",751,-0.05, 7.55, 751, -0.05, 7.55);

  // TMF Momentum
  tmfMomentum_HIST = tfs->make<TH1F>("tmfMomentum_HIST","TMF Momentum; TMF Momentum (GeV/c); Counts / bin", 751,-0.05,7.55);
  tmfMomentumVsTrueMomentum_HIST = tfs->make<TH2F>("tmfMomentumVsTrueMomentum_HIST", "TMF Momentum vs. True Momentum; True Momentum (GeV/c); TMF Momentum (GeV/c)", 751, -0.05, 7.55, 751, -0.05, 7.55);

  // ########################################################################
}

void CompareMCSAnalyzer::endJob() {
}

template<typename Point>
Bool_t CompareMCSAnalyzer::inDetector(Point point) const {
  return 
    point.Z() <= 700 && point.Z() >= 0 &&
    point.X() <= 300  && point.X() >= -300 &&
    point.Y() <= 600 && point.Y() >= 0;
}

Double_t CompareMCSAnalyzer::highland(Double_t p, Double_t l) {
  return (1+0.038*log(l/14))*sqrt(l/14)*(11.004+0.105/(p*p)) /(p*p/sqrt(0.106*0.106+p*p))/1000; //1000 is for converting mrads to rads
}

Double_t CompareMCSAnalyzer::deltaP(Double_t p, Double_t l) {
  double M = 105.66; // MeV/c^2, mass of muon
  double initialE = pow(M*M+p*p,0.5);
  double Z = 18, A = 39.948; //For Ar, do they use a specific Isotope?
  double K = 0.307075; // MeV*cm^2/mol
  double I = 188*pow(10,-6); //MeV
  double m = 0.511; // MeV/c^2, electron mass
  double bg = p/M, bb = (p*p)/(m*m+p*p), gg = (m*m+p*p)/(m*m); //Beta*Gamma, Beta^2, Gamma^2
  double W = (2*m*bb*gg)/(1+(2*m*pow(gg,0.5)/M)+pow(m/M,2));
  double del, a = 0.19559, x0 = 0.2, x1 = 3, C = 5.2146, k = 3, x = log10(bg);
  if(x >= x1)
    del = 0.5*(2*log(10)*x-C);
  else if(x >= x0 && x <= x1)
    del = 0.5*(2*log(10)*x-C+a*pow(x1+x,k));
  else
    del = 0;
  
  //First calculate dEdx (MeV)/cm
  double dEdx = K*(Z/A)*(1/bb)*(0.5*log(2*m*bb*gg*W/(I*I))-bb-del);
  return p-pow(pow(initialE - dEdx*l,2)-M*M,0.5); //Convert MeV to GeV
}

// TODO: THIS IS OLD, DO NOT USE
std::vector<double> CompareMCSAnalyzer::getThetaOverSigma(double p, std::vector<double> thetaXZprimevec, std::vector<double> thetaYZprimevec, std::vector<double> lengthsvec)
{
  std::vector<double> thetaOverSigmavec;
  double mom = p*1000, thetaXZprime, thetaYZprime, l, sigma, sigmaRes;
  for(int i = 0; i <= (int) thetaXZprimevec.size()-1; i++)
    {
      thetaXZprime = thetaXZprimevec.at(i);
      thetaYZprime = thetaYZprimevec.at(i);
      l = lengthsvec.at(i+1);
      sigma = highland(mom/1000,l); // in rads
      sigmaRes = 0.003; // rads
      sigma = std::sqrt(sigma*sigma + sigmaRes*sigmaRes);
      thetaOverSigmavec.push_back(thetaXZprime / sigma);
      thetaOverSigmavec.push_back(thetaYZprime / sigma);
      mom-=deltaP(mom,l);
    }

  return thetaOverSigmavec;
}

Double_t CompareMCSAnalyzer::fractionalDifference(Double_t trueMomentum, Double_t mcsMomentum) {
  return ((1/mcsMomentum) - (1/trueMomentum)) * trueMomentum;
}

DEFINE_ART_MODULE(CompareMCSAnalyzer)
