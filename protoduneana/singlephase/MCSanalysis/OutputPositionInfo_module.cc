////////////////////////////////////////////////////////////////////////
// Class:       OutputPositionInfo
// Module Type: analyzer
// File:        OutputPositionInfo_module.cc
// Author: Hunter Meyer | hmeyer5@lsu.edu
// Advisor: Thomas Kutter
// This analyzer module will output true and reco muon trajectory info,
// including the XvsZ & YvsZ plots, as well output to text files.  This
// module will also compare the number of tracks that were reconstructed
// per MCParticle that created them.
////////////////////////////////////////////////////////////////////////

// C++ Includes
#include <iostream>
#include <fstream>
#include <string>

// Root Includes
#include "TH1F.h"
#include "TH2F.h"

// Framework Includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art_root_io/TFileService.h"

// LArSoft Inclues
#include "nusimdata/SimulationBase/MCParticle.h"
#include "lardataobj/RecoBase/Track.h"

// LSU Includes
#include "MCSSegmentCalculator.h"
#include "BackTrackerAlg.h"

class OutputPositionInfo;

class OutputPositionInfo : public art::EDAnalyzer {
public:

  // fhicl configuration
  struct Config {
    fhicl::Atom<art::InputTag> trackModuleLabel { fhicl::Name("TrackModuleLabel") };
    fhicl::Atom<Bool_t> shouldOutputToFiles { fhicl::Name("ShouldOutputToFiles") };
    fhicl::Atom<std::string> truePosStreamFileName { fhicl::Name("TruePosStreamFileName") };
    fhicl::Atom<std::string> recoPosStreamFileName { fhicl::Name("RecoPosStreamFileName") };
  };
  using MCSSegmentCalculator = trkf::MCSSegmentCalculator;
  using MCSSegmentResult = MCSSegmentCalculator::MCSSegmentResult;
  using Segment_t = MCSSegmentCalculator::Segment_t;
  using Point_t = MCSSegmentCalculator::Point_t;

  //explicit OutputPositionInfo(fhicl::ParameterSet const & p);
  explicit OutputPositionInfo(art::EDAnalyzer::Table<Config> const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  OutputPositionInfo(OutputPositionInfo const &) = delete;
  OutputPositionInfo(OutputPositionInfo &&) = delete;
  OutputPositionInfo & operator = (OutputPositionInfo const &) = delete;
  OutputPositionInfo & operator = (OutputPositionInfo &&) = delete;

  // Art functions.
  void analyze(art::Event const & e) override;
  void beginJob();
  void endJob();

  // Other Functions
  template<typename Vector1, typename Vector2> Double_t distanceBetween(Vector1 vector1, Vector2 vector2) const;
  template<typename Point> Bool_t inDetector(Point point) const;
  TVector3 startingPositionFor(simb::MCParticle particle) const;


private:
  // Retrieved from fhicl parameters
  const art::InputTag fTrackModuleLabel;
  const Bool_t fShouldOutputToFiles;
  const std::string fTruePosStreamFileName;
  const std::string fRecoPosStreamFileName;
  const trkf::MCSSegmentCalculator fSegmentCalculator;

  // True Data
  // =====================================================

  // True Pos Info
  TH2F* trueXvsZ_HIST;
  TH2F* trueYvsZ_HIST;

  std::ofstream truePosStream;
  // =====================================================

  // Reconstructed Data
  // #####################################################

  // Reco Pos Info
  TH2F* recoXvsZ_HIST;
  TH2F* recoYvsZ_HIST;

  TH1F* numberOfMuonTracks_HIST;
  TH1F* numberOfWellReconstructedTracks_HIST;

  TH2F* recoRawSegmentLengthVsDistanceBetweenEndPoints_HIST;
  TH2F* recoSegmentLengthDifferenceVsNumberOfPointsInSegment_HIST;
  TH1F* recoNumberOfPointsInSegment_HIST;
  TH2F* recoRawSegmentLengthVsNumberOfPointsInSegment_HIST;

  std::ofstream recoPosStream;
  // #####################################################

  // Comparing True and Reco Vertex Differences
  TH1F* vertexDeltaX_HIST;
  TH1F* vertexDeltaY_HIST;
  TH1F* vertexDeltaZ_HIST;
  TH1F* vertexDelta3D_HIST;

  TH1F* firstSegmentEndDeltaX_HIST;
  TH1F* firstSegmentEndDeltaY_HIST;
  TH1F* firstSegmentEndDeltaZ_HIST;
  TH1F* firstSegmentEndDelta3D_HIST;
};

OutputPositionInfo::OutputPositionInfo(art::EDAnalyzer::Table<OutputPositionInfo::Config> const & t) :
  art::EDAnalyzer(t),
  fTrackModuleLabel(t().trackModuleLabel()),
  fShouldOutputToFiles(t().shouldOutputToFiles()),
  fTruePosStreamFileName(t().truePosStreamFileName()),
  fRecoPosStreamFileName(t().recoPosStreamFileName()),
  fSegmentCalculator(MCSSegmentCalculator())
{}

void OutputPositionInfo::analyze(art::Event const & e) {
  std::cout << "Event number: " << e.event() << std::endl;

  // simb::MCParticle analysis
  auto particleListHandle = e.getValidHandle<std::vector<simb::MCParticle> >("largeant");
  std::vector<art::Ptr<simb::MCParticle> > particleList;
  art::fill_ptr_vector(particleList, particleListHandle);
  size_t nParticles = particleList.size();
  std::cout << "Number of Particles: " << nParticles << std::endl;
  // Loop through MCParticles
  for(size_t iParticle = 0; iParticle < nParticles; ++iParticle) {

    art::Ptr<simb::MCParticle> particle = particleList.at(iParticle);
    // Only output position info if the trajectory length is greater than 100 cm
    // Only output position info for muons
    if(particle->Trajectory().TotalLength() >= 100 && particle->PdgCode() == 13) {

      // Loop through trajectory points
      for(size_t i = 0; i < particle->NumberTrajectoryPoints(); ++i) {

	TVector3 point = particle->Position(i).Vect();
	if(inDetector(point)) {
	  //if(inDetector(*particle,i)) {
	  trueXvsZ_HIST->Fill(point.Z(), point.X());
	  trueYvsZ_HIST->Fill(point.Z(), point.Y());

	  if(fShouldOutputToFiles) {
	    truePosStream << e.event() << "\t" // Event Number
			  << iParticle << "\t" // Particle Number
			  << particle->P(i) << "\t" // Momentum 
			  << point.X() << "\t"      // xPos
			  << point.Y() << "\t"      // yPos
			  << point.Z() << "\t"      // zPos
			  << std::endl;
	  } // if the fhicl parameter specifies that the info should be written to a file.
	} // if this trajectory point is in the detector

      } // For trajectory point in particle

    } // if particle trajectory length >= 100 cm and PDG == 13

  } // for particle in particleList

  // recob::Track analysis
  auto trackListHandle = e.getValidHandle<std::vector<recob::Track> >(fTrackModuleLabel);
  std::vector<art::Ptr<recob::Track> > trackList;
  art::fill_ptr_vector(trackList,trackListHandle);

  // LSU Backtracker
  // TODO: Consider outputing MCParticle from backtracker rather than looping through all mcparticles above.
  lsu::BackTrackerAlg backtracker;

  Int_t numberOfMuonTracks = 0;

  // Loop through the list of reconstructed tracks
  size_t nTracks = trackList.size();
  std::cout << "Number of Tracks: " << nTracks << std::endl;
  for(size_t iTrack = 0; iTrack < nTracks; iTrack++) {
    art::Ptr<recob::Track> track = trackList.at(iTrack);
    simb::MCParticle particle = backtracker.getMCParticle(track, e, fTrackModuleLabel.label());

    // Only run this analysis if the track length is greater than 100 cm
    if(track->Length() >= 100) {

      // Get a reco segment result, not creating virtual points.
      MCSSegmentResult recoSegmentResult = fSegmentCalculator.GetResult(*track, false);
      std::vector<Segment_t> recoSegment_vec = recoSegmentResult.GetSegment_vec();
      std::vector<Float_t> recoRawSegmentLength_vec = recoSegmentResult.GetRawSegmentLength_vec();

      // Get a true segment result, not creaint virutal points
      MCSSegmentResult trueSegmentResult = fSegmentCalculator.GetResult(particle, false);
      std::vector<Segment_t> trueSegment_vec = trueSegmentResult.GetSegment_vec();
      std::vector<Float_t> trueRawSegmentLength_vec = trueSegmentResult.GetRawSegmentLength_vec();

      // Get the true and reco vertex
      recob::tracking::Point_t recoVertex = recoSegment_vec.at(0).front().underlying();
      recob::tracking::Point_t trueVertex = trueSegment_vec.at(0).front().underlying();

      // Calculate the differences between the true and reco vertices (Difference between the start of the first true and reco segments).
      recob::tracking::Vector_t vertexDifference = recoVertex - trueVertex;

      // Plot the directional differences.
      vertexDeltaX_HIST->Fill(vertexDifference.X());
      vertexDeltaY_HIST->Fill(vertexDifference.Y());
      vertexDeltaZ_HIST->Fill(vertexDifference.Z());
      vertexDelta3D_HIST->Fill(sqrt(vertexDifference.Mag2()));

      // Optionally check if the 3D vertex difference is less than 1 cm. (with an override)
      Bool_t override = false;
      if(vertexDifference.Mag2() < 1 || override) {
	// Compare the last points in the first reco and true segments.
	recob::tracking::Point_t recoFirstSegmentEnd = recoSegment_vec.at(0).back().underlying();
	recob::tracking::Point_t trueFirstSegmentEnd = trueSegment_vec.at(0).back().underlying();

	// Calculate the differences between the end of the first true and reco segment.
	recob::tracking::Vector_t firstSegmentEndDifference = recoFirstSegmentEnd - trueFirstSegmentEnd;

	// Plot diretional differences.
	firstSegmentEndDeltaX_HIST->Fill(firstSegmentEndDifference.X());
	firstSegmentEndDeltaY_HIST->Fill(firstSegmentEndDifference.Y());
	firstSegmentEndDeltaZ_HIST->Fill(firstSegmentEndDifference.Z());
	firstSegmentEndDelta3D_HIST->Fill(sqrt(firstSegmentEndDifference.Mag2()));
      } // if vertexDifference.Mag2() < 1

      for(size_t i = 0; i < track->NumberTrajectoryPoints(); ++i) {
	// Output position info to XvsZ & YvsZ histograms.
	recob::Track::Point_t point = track->LocationAtPoint(i);
	recoXvsZ_HIST->Fill(point.Z(), point.X());
	recoYvsZ_HIST->Fill(point.Z(), point.Y());

	// Ouput position info into this file stream.
	if(fShouldOutputToFiles) {
	  recoPosStream << e.event() << "\t"
			<< iTrack << "\t"
			<< point.X() << "\t"
			<< point.Y() << "\t"
			<< point.Z() << "\t"
			<< std::endl;
	} // if the fhicl parameter specifies that the position info should be written to a file
      } // for i

      // Loop through the segments, print the number of points in a segment.
      for(size_t i = 0; i < recoRawSegmentLength_vec.size(); ++i) {
	Segment_t recoSegment = recoSegment_vec.at(i);
	Float_t recoRawSegmentLength = recoRawSegmentLength_vec.at(i);
	
	size_t numPointsInSegment = recoSegment.size();
	Point_t firstPointInSegment = recoSegment.front();
	Point_t lastPointInSegment = recoSegment.back();
	Float_t distanceBetweenEndPoints = distanceBetween(firstPointInSegment, lastPointInSegment);

	Float_t diff = recoRawSegmentLength - distanceBetweenEndPoints;

	recoNumberOfPointsInSegment_HIST->Fill(numPointsInSegment);
	recoRawSegmentLengthVsNumberOfPointsInSegment_HIST->Fill(numPointsInSegment, recoRawSegmentLength);
	recoRawSegmentLengthVsDistanceBetweenEndPoints_HIST->Fill(distanceBetweenEndPoints, recoRawSegmentLength);
	recoSegmentLengthDifferenceVsNumberOfPointsInSegment_HIST->Fill(numPointsInSegment, diff);

      } // for segment in segment_vec

      ++numberOfMuonTracks;

    } // if length > 100
  } // for iTrack

  // Determines if the track is well-reconstructed
  Bool_t wellReconstructed = numberOfMuonTracks == 1;

  // Fill track-count histograms
  numberOfMuonTracks_HIST->Fill(numberOfMuonTracks);
  numberOfWellReconstructedTracks_HIST->Fill(wellReconstructed ? 1 : 3);

  // Ouptut track-count info to log.
  std::cout << "Number of muon tracks = " << numberOfMuonTracks << std::endl;
  std::cout << "Track was `well-reconstructed`: " << wellReconstructed << std::endl;
} // analyze function

void OutputPositionInfo::beginJob() {
  art::ServiceHandle<art::TFileService> tfs;

  // BEGIN True Data
  // ########################################################################
  // True Position Histograms
  trueXvsZ_HIST = tfs->make<TH2F>("trueXvsZ_HIST","True X vs. Z; z (cm); x (cm)", 701, -0.5, 700.5, 701, -350.5, 350.5);
  trueYvsZ_HIST = tfs->make<TH2F>("trueYvsZ_HIST","True Y vs. Z; z (cm); y (cm)", 701, -0.5, 700.5, 601, -0.5, 600.5);

  // True Position Output Stream Introduction
  truePosStream.open(fTruePosStreamFileName.c_str());
  truePosStream << "event" << "\t"
		<< "par" << "\t"
		<< "mom" << "\t"
		<< "x" << "\t"
		<< "y" << "\t"
		<< "z" << "\t"
		<< std::endl;

  // ########################################################################
  // END True Data

  // BEGIN Reco Data
  // ########################################################################
  // Reco Position Histograms
  recoXvsZ_HIST = tfs->make<TH2F>("recoXvsZ_HIST","Reco X vs. Z; z (cm); x (cm)", 701, -0.5, 700.5, 701, -350.5, 350.5);
  recoYvsZ_HIST = tfs->make<TH2F>("recoYvsZ_HIST","Reco Y vs. Z; z (cm); y (cm)", 701, -0.5, 700.5, 601, -0.5, 600.5);

  numberOfMuonTracks_HIST = tfs->make<TH1F>("numberOfMuonTracks_HIST","Number of muon tracks; Count; Number of entries per count of muon tracks", 21, -0.5, 20.5);
  numberOfWellReconstructedTracks_HIST = tfs->make<TH1F>("numberOfWellReconstructedTracks_HIST", "Number of `Well-Reconstructed` tracks; 1: Well-reco, 3: Not well-reco; Number of tracks", 5, -0.5, 4.5);


  recoRawSegmentLengthVsDistanceBetweenEndPoints_HIST = tfs->make<TH2F>("recoRawSegmentLengthVsDistanceBetweenEndPoints_HIST", "Reco Segment Length Comparison; Distance Between End Points; Raw Segment Length", 281, -0.05, 28.05, 281, -0.05, 28.05);
  recoSegmentLengthDifferenceVsNumberOfPointsInSegment_HIST = tfs->make<TH2F>("recoSegmentLengthDifferenceVsNumberOfPointsInSegment_HIST", "Reco Segment Length Diff vs. Number of points in Segment; Number Of Points in Segment; Raw L - Dist b/w end points", 251, -0.5, 250.5, 281, -0.05, 28.05);
  recoNumberOfPointsInSegment_HIST = tfs->make<TH1F>("recoNumberOfPointsInSegment_HIST", "Reco Number of Points in Segment; Number of Points in Segment;", 251, -0.5, 250.5);
  recoRawSegmentLengthVsNumberOfPointsInSegment_HIST = tfs->make<TH2F>("recoRawSegmentLengthVsNumberOfPointsInSegment_HIST", "Reco Raw Segment Length vs. Number of Points in Segment; Number of Points in Segment; Raw Segment Length", 251, -0.5, 250.5, 281, -0.05, 28.05);

  // Reco Position Output Stream Introduction
  recoPosStream.open(fRecoPosStreamFileName.c_str());
  recoPosStream << "event" << "\t"
		<< "track" << "\t"
		<< "x" << "\t"
		<< "y" << "\t"
		<< "z" << "\t"
		<< std::endl;

  // ########################################################################
  // END Reco Data

  vertexDeltaX_HIST = tfs->make<TH1F>("vertexDeltaX_HIST", "True/Reco Vertex Delta X; Delta X (cm); Hist Counts", 500, 0, 50);
  vertexDeltaY_HIST = tfs->make<TH1F>("vertexDeltaY_HIST", "True/Reco Vertex Delta Y; Delta Y (cm); Hist Counts", 500, 0, 50);
  vertexDeltaZ_HIST = tfs->make<TH1F>("vertexDeltaZ_HIST", "True/Reco Vertex Delta Z; Delta Z (cm); Hist Counts", 500, 0, 50);
  vertexDelta3D_HIST = tfs->make<TH1F>("vertexDelta3D_HIST", "True/Reco Vertex Delta 3D; Delta 3D (cm); Hist Counts", 500, 0, 50);

  firstSegmentEndDeltaX_HIST = tfs->make<TH1F>("firstSegmentEndDeltaX_HIST", "True/Reco First Segment End Delta X; Delta X (cm); Hist Counts", 500, 0, 50);
  firstSegmentEndDeltaY_HIST = tfs->make<TH1F>("firstSegmentEndDeltaY_HIST", "True/Reco First Segment End Delta Y; Delta Y (cm); Hist Counts", 500, 0, 50);
  firstSegmentEndDeltaZ_HIST = tfs->make<TH1F>("firstSegmentEndDeltaZ_HIST", "True/Reco First Segment End Delta Z; Delta Z (cm); Hist Counts", 500, 0, 50);
  firstSegmentEndDelta3D_HIST = tfs->make<TH1F>("firstSegmentEndDelta3D_HIST", "True/Reco First Segment End  Delta 3D; Delta 3D (cm); Hist Counts", 500, 0, 50);
}

void OutputPositionInfo::endJob() {
  truePosStream.close();
  recoPosStream.close();
}

template<typename Point>
Bool_t OutputPositionInfo::inDetector(Point point) const {
  return 
    point.Z() <= 700 && point.Z() >= 0 &&
    point.X() <= 300  && point.X() >= -300 &&
    point.Y() <= 600 && point.Y() >= 0;
}


// Return the distance between two vectors
template<typename Vector1, typename Vector2>
Double_t OutputPositionInfo::distanceBetween(Vector1 vector1, Vector2 vector2) const {

  // Calculate the difference between each vector's components
  Double_t deltaX = vector1.X() - vector2.X();
  Double_t deltaY = vector1.Y() - vector2.Y();
  Double_t deltaZ = vector1.Z() - vector2.Z();

  // Calculate and return the difference between the two vectors by adding the difference in the components in quadrature.
  Double_t diff = sqrt(deltaX*deltaX + deltaY*deltaY + deltaZ*deltaZ);
  return diff;
} // MCSAngleAnalysis::distanceBetween(Vector1, Vector2)

// Returns the first point in the detector for the specified MCParticle
TVector3 OutputPositionInfo::startingPositionFor(simb::MCParticle particle) const {
  for(size_t i = 0; i < particle.NumberTrajectoryPoints(); ++i) {
    if(inDetector(particle.Position(i)))
      return particle.Position(i).Vect();
  }

  return TVector3(-999,-999,-999);
}

DEFINE_ART_MODULE(OutputPositionInfo)
